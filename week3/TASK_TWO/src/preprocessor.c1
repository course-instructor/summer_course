#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>
#include <unistd.h>
#include <limits.h>

#include <../headers/preprocessor.h>


boolean_e check_comment_start(char chr, FILE * file)
{
    boolean_e ret = FALSE;
    if (chr == '/')
    {
        chr = fgetc(file);

        if (chr == '*')
        {
            ret = TRUE;
        }
        else
        {

            if(fseek(file, -1, SEEK_CUR))
            {
                perror("Error on fseek in check_comment_start");
            }
        }
    }
    return ret;
}


boolean_e check_comment_end(char chr, FILE * file)
{
    boolean_e ret = FALSE;
    if (chr == '*')
    {
        chr = fgetc(file);

        if (chr == '/')
        {
            ret = TRUE;
        }
        else
        {
            if(fseek(file, -1, SEEK_CUR))
            {
                perror("Error on fseek in check_comment_end");
            }
        }
    }
    return ret;
}


void remove_comments( char * c_file_name)
{
    char * c1_file_name = malloc(strlen(c_file_name) + 1);
    FILE * c_file;
    FILE * c1_file;

    char chr;
    boolean_e in_comment = FALSE;



    strcpy(c1_file_name,c_file_name);
    strcat(c1_file_name, "1");

    c_file = fopen(c_file_name, "r");
    c1_file = fopen(c1_file_name, "w");

    if(!c_file)
    {
        perror("Error opening c_file\n");

    }

    else if(!c1_file)
    {
        perror("Error opening c1_file\n");
    }

    else
    {
        while ((chr = fgetc(c_file)) != EOF)
        {
            if(!in_comment)
            {
                if(check_comment_start(chr, c_file))
                {
                    in_comment = TRUE;
                }
                else
                {
                    fputc(chr, c1_file);
                }
            }

            else
            {
                if(check_comment_end(chr, c_file))
                {
                    in_comment = FALSE;
                }
            }
        }
    }
    fclose(c_file);
    fclose(c1_file);
}


void find_header(char * line, char * ret)
{
    char file_name[FILE_NAME_LENGTH];
    char temp[FILE_NAME_LENGTH];

    if(sscanf(line, "#include \"%[^\"]\"", temp) == 1)
    {
        if(!realpath(file_name,temp))
        {
            perror("error realpath in find_header\n");
            file_name[0] = '\0';
        }
    }
    else
    {
        file_name[0] = '\0';
    }
    strncpy(ret, file_name, FILE_NAME_LENGTH);
    ret[FILE_NAME_LENGTH-1] = '\0';

}

boolean_e check_storm(ENTRY * entry, char * file_path)
{
    boolean_e ret;

    if(strstr((char *)entry->data,file_path))
    {
        printf("storm detected!\n");
        ret = TRUE;
    }
    else
    {


        ret = FALSE;
    }

    return(ret);
}




void handle_call(FILE * c2_file,char * header_path, char * father_path)
{
    ENTRY entry;
    FILE * header_file = fopen(header_path, "r");

    entry.key = header_path;
    entry.data = NULL;

    if(!header_file)
    {
        printf("error opening file: handle_call\n");
    }
    else
    {
        ENTRY * temp = hsearch(entry,FIND);
        if(!temp)
        {

            strncpy((char *)entry.data, father_path,FILE_NAME_LENGTH);
            ((char *)entry.data) [FILE_NAME_LENGTH - 1] = '\0';
            hsearch(entry, ENTER);

            func(c2_file, header_file,header_path);

        }
        else
        {
            if(check_storm(temp, father_path) != FALSE)
            {
                strncat((char *) temp->data, father_path, FILE_NAME_LENGTH); 
                hsearch(*temp, ENTER); 
            }

        }
        fclose(header_file);
    }
}



void func(FILE * file, FILE * head, char * father_path)
{
    char line [LINE_LENGTH];
    char header_path[FILE_NAME_LENGTH];
    header_path[0] = '\0';

    while (fgets(line,LINE_LENGTH, head))
    {
        find_header(line, header_path);
        if(*header_path)
        {
            handle_call(file,header_path,father_path);
        }
        else
        {
            fwrite(line, sizeof(char), LINE_LENGTH, file);
        }
    }
}

void turn_c1_to_c2(char * c1_file_name)
{
    char  c2_path[LINE_LENGTH];
    FILE * c2_file;
    FILE * c1_file;



    if(!hcreate(HASH_SIZE))
    {
        printf("error creating hash");
    }
    else
    {
        strncpy(c2_path, c1_file_name, LINE_LENGTH);
        c1_file = fopen(c1_file_name,"r");
        c2_file = fopen(c2_path,"w");

        if(!c1_file || !c2_file)
        {
            printf("error opening file in storm check\n");
        }

        else
        {
            func(c2_file,c1_file, NULL);
        }

        hdestroy();
    }

}

int main()
{
    char * c_file_name = "src/preprocessor.c";
    remove_comments(c_file_name);
    return 0;
}
